import {Image, Appear, Notes} from 'mdx-deck'
import {CodeSurfer, CodeSurferColumns, Step} from 'code-surfer'
import {vsDark} from '@code-surfer/themes'

import Me from './Me'
import References from './References'
import Multiline from './Multiline'
import Logos from './Logos'

import complexity from './images/complexity.jpeg'
import documents from './images/documents.jpeg'
import typescript from './images/typescript.png'

export const theme = vsDark;

<Multiline
  Elem="h1"
  margin={50}
  lines={['Modeling your way', 'to consistency']}
/>

<small>
  <a href="http://bit.ly/dotjs-modeling" target="_blank">bit.ly/dotjs-modeling</a>
</small>

---

<img src={typescript} width="300"/>

---

<img src={typescript} width="300"/>

<Logos />

<Notes>

Disclaimer!

It works for other languages as well

Even JS -> but the compiler helps A LOT

</Notes>

---

<Image src={documents} />

<Notes>

Web: Documents (past)

</Notes>

---

<Image src={complexity} />

<Notes>

Web: Apps (today)

**Complexity** (elaborate flows)

</Notes>

---

## Domain Modeling

<Appear>

üòï Conditions us ü§ê

</Appear>

<Notes>

Central piece of building things right

way we model -> way we work

</Notes>

---

<Notes>

Common way to represent data loaded asynchronously

</Notes>

<CodeSurfer>

```ts
interface AsyncUser {
  isLoading: boolean
  didLoad: boolean
  data?: User
  error?: Error
}
```

</CodeSurfer>

---

<CodeSurfer>

```ts
const idle = {
  isLoading: false,
  didLoad: false,
  data: undefined,
  error: undefined,
}

const loading = {
  isLoading: true,
  didLoad: false,
  data: undefined,
  error: undefined,
}
```

</CodeSurfer>

---

<CodeSurfer>

```ts
const success = {
  isLoading: false,
  didLoad: true,
  data: user,
  error: undefined,
}

const failure = {
  isLoading: false,
  didLoad: true,
  data: undefined,
  error: error,
}
```

</CodeSurfer>

---

<CodeSurfer>

```ts 2[3,4,7:21],3,6[3,4,7:34],7,10[3,4,7:34],11,14
const LoadingUser: React.FC<AsyncUser> = (props) => {
  if (props.isLoading) {
    return <Loading />
  }

  if (props.didLoad && props.error) {
    return <ErrorMessage error={props.error} />
  }

  if (props.didLoad && props.data) {
    return <UserCard user={props.data} />
  }

  return <Idle />
}
```

```jsx 1:22
interface AsyncUser {
  isLoading: boolean
  didLoad: boolean
  data?: User
  error?: Error
}

const LoadingUser: React.FC<AsyncUser> = (props) => {
  if (props.isLoading) {
    return <Loading />
  }

  if (props.didLoad && props.error) {
    return <ErrorMessage error={props.error} />
  }

  if (props.didLoad && props.data) {
    return <UserCard user={props.data} />
  }

  return <Idle />
}
```

</CodeSurfer>

---

<Multiline lines={['üö¢ üì¶', 'All good, right?']} />

<Notes>

All good!

Ship it like it's hot!

</Notes>

---

<Multiline lines={['What if ... ?', 'ü§î']} />

---

<Notes>

No single source of truth

Status depends on several values

Not all possible combinations are valid

\---

Let's try to fix it:

1. Make it generic
1. Only one value controls the status

</Notes>

<CodeSurfer>

```ts title="üò± What does this even ? ü§î"
const leWhat = {
  isLoading: true,
  didLoad: true,
  data: user,
  error: someError,
}
```

</CodeSurfer>

---

<CodeSurfer>

```ts 1[11:22],4 title="Let's make it generic first"
interface AsyncData<T> {
  isLoading: boolean
  didLoad: boolean
  data?: T
  error?: Error
}
```

```diff 2:3 title="üòí No single source of truth üëé"

```

```ts
type Status =
  | 'idle'
  | 'loading'
  | 'success'
  | 'failure'

interface AsyncData<T> {
  status: Status
  data?: T
  error?: Error
}
```

```jsx 2[7:29],6[7:32],10[7:47],14[7:46] title="üòé Single source of truth üëç"
const LoadingUser: React.FC<AsyncData<User>> = (props) => {
  if (props.status === 'idle') {
    return <Idle />
  }

  if (props.status === 'loading') {
    return <Loading />
  }

  if (props.status === 'failure' && props.error) {
    return <ErrorMessage error={props.error} />
  }

  if (props.status === 'success' && props.data) {
    return <UserCard user={props.data} />
  }

  return null
}
```

```jsx 1:31
type Status =
  | 'idle'
  | 'loading'
  | 'success'
  | 'failure'

interface AsyncData<T> {
  status: Status
  data?: T
  error?: Error
}

const LoadingUser: React.FC<AsyncData<User>> = (props) => {
  if (props.status === 'idle') {
    return <Idle />
  }

  if (props.status === 'loading') {
    return <Loading />
  }

  if (props.status === 'failure' && props.error) {
    return <ErrorMessage error={props.error} />
  }

  if (props.status === 'success' && props.data) {
    return <UserCard user={props.data} />
  }

  return null
}
```

</CodeSurfer>

---

<Notes>

Now we did it!

Send it to prod, I want to go home!

</Notes>

<Multiline lines={['üö¢ üì¶', 'Ok, now is all good, right?']} />

---

<Notes>

It never is ...

</Notes>

<Multiline lines={[<span>But, is it <i>tho</i> ?</span>, 'ü§î']} />

---

<CodeSurfer>

```ts 13:23 title="ü§∑ Again John? ü§¶"
type Status =
  | 'idle'
  | 'loading'
  | 'success'
  | 'failure'

interface AsyncData<T> {
  status: Status
  data?: T
  error?: Error
}

const queEsEsto = {
  status: 'idle',
  data: user,
  error: error,
}

const whoDidThis = {
  status: 'success',
  data: undefined,
  error: undefined,
}
```

</CodeSurfer>

---

<Multiline lines={['Discriminated Unions', 'ü¶∏ to the rescue ü¶∏']} />

<Notes>

Not specific to TS tho!

</Notes>

---

<Notes>

Can we attatch the data to the status?

</Notes>

<CodeSurfer>

```ts
type Status =
  | 'idle'
  | 'loading'
  | 'success'
  | 'failure'

interface AsyncData<T> {
  status: Status
  data?: T
  error?: Error
}
```

```ts
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}
```

```diff 4[25:31],5[25:36] title="No more optional values ü§Ø"

```

</CodeSurfer>

<!--
Not merged because wider (last) snippet makes initial (less wide) snippets smaller
-->

---

<CodeSurfer>

```jsx 8[3,4,7:29],9,12[3,4,7:32],13,16[3,4,7:32],17,20
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

const LoadingUser: React.FC<AsyncData<User>> = (props) => {
  if (props.status === 'idle') {
    return <Idle />
  }

  if (props.status === 'loading') {
    return <Loading />
  }

  if (props.status === 'failure') {
    return <ErrorMessage error={props.error} />
  }

  return <UserCard user={props.data} />
}
```

```diff 1:24

```

</CodeSurfer>

---

### Ok, now is all good üòÖ

---

<Multiline
  Elem="h3"
  lines={['üôÑ Maybe ... üëÄ', 'We can still improve it?']}
/>

<Notes>

More changes?

Yeah!

</Notes>

---

<CodeSurfer>

```ts title="What do we want to do for each case? ü§®"
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}
```

```ts
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

interface Matcher<T, R> {
  idle: () => R
  loading: () => R
  success: (data: T) => R
  failure: (error: Error) => R
}
```

```ts
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

interface Matcher<T, R> {
  idle: () => R
  loading: () => R
  success: (data: T) => R
  failure: (error: Error) => R
}

const LoadingUser: React.FC<AsyncData<User>> = (props) => {
  if (props.status === 'idle') {
    return <Idle />
  }

  if (props.status === 'loading') {
    return <Loading />
  }

  if (props.status === 'failure') {
    return <ErrorMessage error={props.error} />
  }

  return <UserCard user={props.data} />
}
```

```ts
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

interface Matcher<T, R> {
  idle: () => R
  loading: () => R
  success: (data: T) => R
  failure: (error: Error) => R
}

const match = <T, R>(m: Matcher<T, R>, ad: AsyncData<T>): R => {
  if (ad.status === 'idle') {
    return m.idle()
  }

  if (ad.status === 'loading') {
    return m.loading()
  }

  if (ad.status === 'failure') {
    return m.success(ad.error)
  }

  return m.success(ad.data)
}
```

```diff 15[7:26],16[12:19],19[7:29],20[12:22],23[7:29],24[12:30],27[10:27]

```

```ts 31[3:30],32:39
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

interface Matcher<T, R> {
  idle: () => R
  loading: () => R
  success: (data: T) => R
  failure: (error: Error) => R
}

const match = <T, R>(m: Matcher<T, R>, ad: AsyncData<T>) => {
  if (ad.status === 'idle') {
    return m.idle()
  }

  if (ad.status === 'loading') {
    return m.loading()
  }

  if (ad.status === 'failure') {
    return m.success(ad.error)
  }

  return m.success(ad.data)
}

const LoadingUser: React.FC<AsyncData<User>> = (props) =>
  match<User, React.ReactNode>(
    {
      idle: () => <Idle />,
      loading: () => <Loading />,
      failure: (error) => <ErrorMessage error={error} />,
      success: (user) => <UserCard user={user} />,
    },
    props,
  )
```

```diff 1:40

```

```diff 1:28

```

```diff 30:40

```

</CodeSurfer>

---

### üìù Let's recap ...

---

<Notes>

- No single source of truth
- Error prone
- Relies on tests a lot

</Notes>

<CodeSurfer>

```jsx 1:22
interface AsyncUser {
  isLoading: boolean
  didLoad: boolean
  data?: User
  error?: Error
}

const LoadingUser: React.FC<AsyncUser> = (props) => {
  if (props.isLoading) {
    return <Loading />
  }

  if (props.didLoad && props.error) {
    return <ErrorMessage error={props.error} />
  }

  if (props.didLoad && props.data) {
    return <UserCard user={props.data} />
  }

  return <Idle />
}
```

</CodeSurfer>

---

<Notes>

- Union types -> Unified status
- Single source of truth (kinda)
- Still can be inconsistent

</Notes>

<CodeSurfer>

```jsx 1:25
interface AsyncData {
  status: 'idle' | 'loading' | 'failure' | 'success'
  data?: User
  error?: Error
}

const LoadingUser: React.FC<AsyncData<User>> = (props) => {
  if (props.status === 'idle') {
    return <Idle />
  }

  if (props.status === 'loading') {
    return <Loading />
  }

  if (props.status === 'failure' && props.error) {
    return <ErrorMessage error={props.error} />
  }

  if (props.status === 'success' && props.data) {
    return <UserCard user={props.data} />
  }

  return null
}
```

</CodeSurfer>

---

<Notes>

- Discriminated unions
- Always consistent !!!
- More verbose
- No need to test (consistency)
- Tests focus on what matters

</Notes>

<CodeSurfer>

```jsx 1:21
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

const LoadingUser: React.FC<AsyncData<User>> = (props) => {
  if (props.status === 'idle') {
    return <Idle />
  }

  if (props.status === 'loading') {
    return <Loading />
  }

  if (props.status === 'failure') {
    return <ErrorMessage error={props.error} />
  }

  return <UserCard user={props.data} />
}
```

</CodeSurfer>

---

<Notes>

- Declarative (no verbosity)
- Reusable code (verbosity)

</Notes>

<CodeSurfer>

```jsx
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

const match = <T, R>(m: Matcher<T, R>, ad: AsyncData<T>) => {
  if (ad.status === 'idle') {
    return m.idle()
  }

  if (ad.status === 'loading') {
    return m.loading()
  }

  if (ad.status === 'failure') {
    return m.success(ad.error)
  }

  return m.success(ad.data)
}

const LoadingUser: React.FC<AsyncData<User>> = (props) =>
  match<User, React.ReactNode>(
    {
      idle: () => <Idle />,
      loading: () => <Loading />,
      failure: (error) => <ErrorMessage error={error} />,
      success: (user) => <UserCard user={user} />,
    },
    props,
  )
```

</CodeSurfer>

---

## Domain Modeling

<Appear>

### üí™ enables us üëç

</Appear>

---

### üìö Resources ü§ì

<References />

---

<Multiline
  lines={['ü§ìü¶Ñüòè', 'Happy & Safe Coding!']}
/>

<p style={{ marginTop: 0, fontWeight: 'bold' }}>Thanks! üëã</p>

<small>
  <a href="http://bit.ly/dotjs-modeling" target="_blank">bit.ly/dotjs-modeling</a>
</small>
