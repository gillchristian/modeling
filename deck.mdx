import {Image, Appear, Notes} from 'mdx-deck'
import {CodeSurfer, CodeSurferColumns, Step} from 'code-surfer'
import {vsDark} from '@code-surfer/themes'

import Me from './Me'
import References from './References'
import Multiline from './Multiline'

import complexity from './images/complexity.jpeg'
import documents from './images/documents.jpeg'
import typescript from './images/typescript.png'

export const theme = vsDark;

<Multiline
  Elem="h1"
  margin={50}
  lines={['Modeling your way', 'to consistency']}
/>

<small>
  <a href="http://bit.ly/dotjs-modeling" target="_blank">bit.ly/dotjs-modeling</a>
</small>

---

<img src="https://github.com/remojansen/logo.ts/raw/master/ts.png" width="300"/>

<Notes>

Disclaimer!

It works for other languages as well

Even JS -> but the compiler helps A LOT

</Notes>

---

<Image src={documents} />

<Notes>

Web: Documents (past)

</Notes>

---

<Image src={complexity} />

<Notes>

Web: Apps (today)

**Complexity** (elaborate flows)

</Notes>

---

## Domain Modeling

<Appear>

üòï Conditions us ü§ê

</Appear>

<Notes>

Central piece of building things right

way we model -> way we work

</Notes>

---

<Notes>

Common way to represent data loaded asynchronously

</Notes>

<CodeSurfer>

```ts
interface AsyncUser {
  isLoading: boolean
  didLoad: boolean
  data?: User
  error?: Error
}
```

```ts
interface AsyncUser {
  isLoading: boolean
  didLoad: boolean
  data?: User
  error?: Error
}

const idle = {
  isLoading: false,
  didLoad: false,
  data: undefined,
  error: undefined,
}
```

```ts
interface AsyncUser {
  isLoading: boolean
  didLoad: boolean
  data?: User
  error?: Error
}

const idle = {
  isLoading: false,
  didLoad: false,
  data: undefined,
  error: undefined,
}

const loading = {
  isLoading: true,
  didLoad: false,
  data: undefined,
  error: undefined,
}
```

```ts
interface AsyncUser {
  isLoading: boolean
  didLoad: boolean
  data?: User
  error?: Error
}

const idle = {
  isLoading: false,
  didLoad: false,
  data: undefined,
  error: undefined,
}

const loading = {
  isLoading: true,
  didLoad: false,
  data: undefined,
  error: undefined,
}

const success = {
  isLoading: false,
  didLoad: true,
  data: user,
  error: undefined,
}
```

```ts
interface AsyncUser {
  isLoading: boolean
  didLoad: boolean
  data?: User
  error?: Error
}

const idle = {
  isLoading: false,
  didLoad: false,
  data: undefined,
  error: undefined,
}

const loading = {
  isLoading: true,
  didLoad: false,
  data: undefined,
  error: undefined,
}

const success = {
  isLoading: false,
  didLoad: true,
  data: user,
  error: undefined,
}

const failure = {
  isLoading: false,
  didLoad: true,
  data: undefined,
  error: new Error('Fetch error'),
}
```

```ts 2[3,4,7:21],3,6[3,4,7:34],7,10[3,4,7:34],11,14
const LoadingUser: React.FC<AsyncUser> = (props) => {
  if (props.isLoading) {
    return <Loading />
  }

  if (props.didLoad && props.error) {
    return <ErrorMessage error={props.error} />
  }

  if (props.didLoad && props.data) {
    return <UserCard user={props.data} />
  }

  return <Idle />
}
```

```jsx 1:22
interface AsyncUser {
  isLoading: boolean
  didLoad: boolean
  data?: User
  error?: Error
}

const LoadingUser: React.FC<AsyncUser> = (props) => {
  if (props.isLoading) {
    return <Loading />
  }

  if (props.didLoad && props.error) {
    return <ErrorMessage error={props.error} />
  }

  if (props.didLoad && props.data) {
    return <UserCard user={props.data} />
  }

  return <Idle />
}
```

</CodeSurfer>

---

<Multiline lines={['üö¢ üì¶', 'All good, right?']} />

<Notes>

All good!

Ship it like it's hot!

</Notes>

---

<Multiline lines={['What if ... ?', 'ü§î']} />

---

<Notes>

No single source of truth

Status depends on several values

Not all possible combinations are valid

\---

Let's try to fix it:

1. Make it generic
1. Only one value controls the status

</Notes>

<CodeSurfer>

```ts 8:13 subtitle="üò± What does that even ? ü§î"
interface AsyncUser {
  isLoading: boolean
  didLoad: boolean
  data?: User
  error?: Error
}

const leWhat = {
  isLoading: true,
  didLoad: true,
  data: user,
  error: someError,
}
```

```ts title="Let's make it generic first"
interface AsyncData<T> {
  isLoading: boolean
  didLoad: boolean
  data?: T
  error?: Error
}
```

```diff 2:3 title="üòí No single source of truth üëé"

```

```ts
type Status =
  | 'idle'
  | 'loading'
  | 'success'
  | 'failure'

interface AsyncData<T> {
  status: Status
  data?: T
  error?: Error
}
```

```jsx 2[7:29],6[7:32],10[7:47],14[7:46] title="üòé Single source of truth üëç"
const LoadingUser: React.FC<AsyncData<User>> = (props) => {
  if (props.status === 'idle') {
    return <Idle />
  }

  if (props.status === 'loading') {
    return <Loading />
  }

  if (props.status === 'failure' && props.error) {
    return <ErrorMessage error={props.error} />
  }

  if (props.status === 'success' && props.data) {
    return <UserCard user={props.data} />
  }

  return null
}
```

```jsx 1:31
type Status =
  | 'idle'
  | 'loading'
  | 'success'
  | 'failure'

interface AsyncData<T> {
  status: Status
  data?: T
  error?: Error
}

const LoadingUser: React.FC<AsyncData<User>> = (props) => {
  if (props.status === 'idle') {
    return <Idle />
  }

  if (props.status === 'loading') {
    return <Loading />
  }

  if (props.status === 'failure' && props.error) {
    return <ErrorMessage error={props.error} />
  }

  if (props.status === 'success' && props.data) {
    return <UserCard user={props.data} />
  }

  return null
}
```

</CodeSurfer>

---

<Notes>

Now we did it!

Send it to prod, I want to go home!

</Notes>

<Multiline lines={['üö¢ üì¶', 'Ok, now is all good, right?']} />

---

<Notes>

It never is ...

</Notes>

<Multiline lines={[<span>But, is it <i>tho</i> ?</span>, 'ü§î']} />

---

<CodeSurfer>

```ts 13:23 subtitle="ü§∑ Again Joe? ü§¶‚ôÇÔ∏è"
type Status =
  | 'idle'
  | 'loading'
  | 'success'
  | 'failure'

interface AsyncData<T> {
  status: Status
  data?: T
  error?: Error
}

const queEsEsto = {
  status: 'idle',
  data: user,
  error: new Error('Fetch error'),
}

const whoDidThis = {
  status: 'success',
  data: undefined,
  error: undefined,
}
```

</CodeSurfer>

---

<Multiline
  lines={[
    <a href={typescript} target="_blank">
      Discriminated Unions
    </a>,
    'ü¶∏ to the rescue ü¶∏',
  ]}
/>

<Notes>

Not specific to TS tho!

</Notes>

---

<Notes>

Can we attatch the data to the status?

</Notes>

<CodeSurfer>

```ts
type Status =
  | 'idle'
  | 'loading'
  | 'success'
  | 'failure'

interface AsyncData<T> {
  status: Status
  data?: T
  error?: Error
}
```

```diff 8:10

```

```ts
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}
```

```diff 4[25:31],5[25:36] subtitle="No more optional values ü§Ø"

```

</CodeSurfer>

<!--
Not merged because wider (last) snippet makes initial (less wide) snippets smaller
-->

---

<CodeSurfer>

```jsx 8[3,4,7:29],9,12[7:32],13,16[7:32],17,20
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

const LoadingUser: React.FC<AsyncData<User>> = (props) => {
  if (props.status === 'idle') {
    return <Idle />
  }

  if (props.status === 'loading') {
    return <Loading />
  }

  if (props.status === 'failure') {
    return <ErrorMessage error={props.error} />
  }

  return <UserCard user={props.data} />
}
```

```diff 1:24

```

</CodeSurfer>

---

### Ok, now is all good üòÖ

---

<Multiline
  lines={['Can we improve it?', 'üôÑ Maybe ... üëÄ']}
/>

<Notes>

More changes?

</Notes>

---

### Let's make it declarative üó∫ 

---

<CodeSurfer>

```ts subtitle="What do we want to do for each case? ü§®"
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}
```

```ts
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

interface Matcher<T, R> {
  idle: () => R
  loading: () => R
  success: (data: T) => R
  failure: (error: Error) => R
}
```

<!-- TODO: can this be two columns??? -->

```diff 2:5,8:11

```

```ts
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

interface Matcher<T, R> {
  idle: () => R
  loading: () => R
  success: (data: T) => R
  failure: (error: Error) => R
}

const LoadingUser: React.FC<AsyncData<User>> = (props) => {
  if (props.status === 'idle') {
    return <Idle />
  }

  if (props.status === 'loading') {
    return <Loading />
  }

  if (props.status === 'failure') {
    return <ErrorMessage error={props.error} />
  }

  return <UserCard user={props.data} />
}
```

```ts
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

interface Matcher<T, R> {
  idle: () => R
  loading: () => R
  success: (data: T) => R
  failure: (error: Error) => R
}

const match = <T, R>(m: Matcher<T, R>, ad: AsyncData<T>): R => {
  if (ad.status === 'idle') {
    return m.idle()
  }

  if (ad.status === 'loading') {
    return m.loading()
  }

  if (ad.status === 'failure') {
    return m.success(ad.error)
  }

  return m.success(ad.data)
}
```

```diff 14[15:59],15[7:26],16[12:19],19[7:29],20[12:22],23[7:29],24[12:30],27[10:27]

```

```ts 31[3:30],32:39
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

interface Matcher<T, R> {
  idle: () => R
  loading: () => R
  success: (data: T) => R
  failure: (error: Error) => R
}

const match = <T, R>(m: Matcher<T, R>, ad: AsyncData<T>) => {
  if (ad.status === 'idle') {
    return m.idle()
  }

  if (ad.status === 'loading') {
    return m.loading()
  }

  if (ad.status === 'failure') {
    return m.success(ad.error)
  }

  return m.success(ad.data)
}

const LoadingUser: React.FC<AsyncData<User>> = (props) =>
  match<User, React.ReactNode>(
    {
      idle: () => <Idle />,
      loading: () => <Loading />,
      failure: (error) => <ErrorMessage error={error} />,
      success: (user) => <UserCard user={user} />,
    },
    props,
  )
```

```diff 1:40

```

```diff 1:28

```

```diff 30:40

```

</CodeSurfer>

---

### üìù Let's recap ...

---

<Notes>

1. No single source of truth, error prone

1. Union types -> Single source

1. Discriminated unions

1. Declarative reusable code

</Notes>

<CodeSurfer>

```jsx 1:22
interface AsyncUser {
  isLoading: boolean
  didLoad: boolean
  data?: User
  error?: Error
}

const LoadingUser: React.FC<AsyncUser> = (props) => {
  if (props.isLoading) {
    return <Loading />
  }

  if (props.didLoad && props.error) {
    return <ErrorMessage error={props.error} />
  }

  if (props.didLoad && props.data) {
    return <UserCard user={props.data} />
  }

  return <Idle />
}
```

```jsx 1:25
interface AsyncData {
  status: 'idle' | 'loading' | 'failure' | 'success'
  data?: User
  error?: Error
}

const LoadingUser: React.FC<AsyncData<User>> = (props) => {
  if (props.status === 'idle') {
    return <Idle />
  }

  if (props.status === 'loading') {
    return <Loading />
  }

  if (props.status === 'failure' && props.error) {
    return <ErrorMessage error={props.error} />
  }

  if (props.status === 'success' && props.data) {
    return <UserCard user={props.data} />
  }

  return null
}
```

```jsx 1:21
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

const LoadingUser: React.FC<AsyncData<User>> = (props) => {
  if (props.status === 'idle') {
    return <Idle />
  }

  if (props.status === 'loading') {
    return <Loading />
  }

  if (props.status === 'failure') {
    return <ErrorMessage error={props.error} />
  }

  return <UserCard user={props.data} />
}
```

```jsx 1:5,23:32
type AsyncData<T> =
  | {status: 'idle'}
  | {status: 'loading'}
  | {status: 'success', data: T}
  | {status: 'failure', error: Error}

const match = <T, R>(m: Matcher<T, R>, ad: AsyncData<T>) => {
  if (ad.status === 'idle') {
    return m.idle()
  }

  if (ad.status === 'loading') {
    return m.loading()
  }

  if (ad.status === 'failure') {
    return m.success(ad.error)
  }

  return m.success(ad.data)
}

const LoadingUser: React.FC<AsyncData<User>> = (props) =>
  match<User, React.ReactNode>(
    {
      idle: () => <Idle />,
      loading: () => <Loading />,
      failure: (error) => <ErrorMessage error={error} />,
      success: (user) => <UserCard user={user} />,
    },
    props,
  )
```

</CodeSurfer>

---

## Domain Modeling

<Appear>

### üí™ enables us üëç

</Appear>

---

### üìö Resources ü§ì

<References />

---

<Multiline
  lines={['Happy & Safe Coding!', 'ü§ìü¶Ñüòè']}
/>

<p style={{ marginTop: 0, fontWeight: 'bold' }}>Thanks! üëã</p>

<small>
  <a href="http://bit.ly/dotjs-modeling" target="_blank">bit.ly/dotjs-modeling</a>
</small>
